From 44db6066b2f537bd8f481d57e2948d6b56d47f69 Mon Sep 17 00:00:00 2001
From: Greg Thain <gthain@cs.wisc.edu>
Date: Fri, 8 Apr 2016 13:16:23 -0500
Subject: [PATCH 1/2] Docker universe now measure user and sys cpu usage #5609

(cherry picked from commit bb94e12623206e0d275a87714fba422dc9879e07)
---
 src/condor_starter.V6.1/docker-api.cpp  | 109 ++++++++++++++++++++++++++++++++
 src/condor_starter.V6.1/docker-api.h    |   2 +-
 src/condor_starter.V6.1/docker_proc.cpp |  22 ++++---
 src/condor_starter.V6.1/docker_proc.h   |   3 +
 4 files changed, 127 insertions(+), 9 deletions(-)

diff --git a/src/condor_starter.V6.1/docker-api.cpp b/src/condor_starter.V6.1/docker-api.cpp
index c0211ec..b4455e3 100644
--- a/src/condor_starter.V6.1/docker-api.cpp
+++ b/src/condor_starter.V6.1/docker-api.cpp
@@ -7,10 +7,15 @@
 #include "condor_classad.h"
 #include "condor_daemon_core.h"
 #include "file_lock.h"
+#include "condor_rw.h"
 
 #include "docker-api.h"
 #include <algorithm>
 
+#if !defined(WIN32)
+#include <sys/un.h>
+#endif
+
 static bool add_env_to_args_for_docker(ArgList &runArgs, const Env &env);
 static bool add_docker_arg(ArgList &runArgs);
 static int run_simple_docker_command(	const std::string &command,
@@ -272,6 +277,7 @@ DockerAPI::unpause( const std::string & container, CondorError & err ) {
 	return run_simple_docker_command("unpause", container, err);
 }
 
+#if 0
 static uint64_t
 convertUnits(uint64_t raw, char *unit) {
 	switch (*unit) {
@@ -294,9 +300,110 @@ convertUnits(uint64_t raw, char *unit) {
 		break;
 	}
 }
+#endif
 
+
+	/* Find usage stats on a running container by talking
+ 	 * directly to the server
+ 	 */
+ 	 
+int
+DockerAPI::stats(const std::string &container, uint64_t &memUsage, uint64_t &netIn, uint64_t &netOut, uint64_t &userCpu, uint64_t &sysCpu) {
+
+#if defined(WIN32)
+	return -1;
+#else
+
+	/*
+ 	 * Create a Unix domain socket 
+ 	 *
+ 	 * This is what the docker server listens on
+ 	 */
+
+	int uds = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (uds < 0) {
+		dprintf(D_ALWAYS, "Can't create unix domain socket, no docker statistics will be available\n");
+		return -1;
+	}
+
+	struct sockaddr_un sa;
+	memset(&sa, 0, sizeof(sa));
+	
+	sa.sun_family = AF_UNIX;
+	strncpy(sa.sun_path, "/var/run/docker.sock",sizeof(sa.sun_path) - 1);
+
+	{
+	TemporaryPrivSentry sentry(PRIV_ROOT);
+	int cr = connect(uds, (struct sockaddr *) &sa, sizeof(sa));
+	if (cr != 0) {
+		dprintf(D_ALWAYS, "Can't connect to /var/run/docker.sock %s, no statistics will be available\n", strerror(errno));
+		close(uds);
+		return -1;
+	}
+	}
+
+	char request[256];
+
+	sprintf(request, "GET /containers/%s/stats?stream=0 HTTP/0.9\r\n\r\n", container.c_str());
+	int ret = write(uds, request, strlen(request));
+	if (ret < 0) {
+		dprintf(D_ALWAYS, "Can't send request to docker server, no statistics will be available\n");
+		close(uds);
+		return -1;
+	}
+
+	std::string response;
+
+	char buf[1024];
+	int written;
+
+	// read with 200 second timeout, no flags, nonblocking
+	while ((written = condor_read("Docker Socket", uds, buf, 1024, 200, 0, false)) > 0) {
+		response.append(buf, written);
+	}
+	dprintf(D_FULLDEBUG, "docker stats: %s\n", response.c_str());
+	close(uds);
+
+	// Response now contains an enormous JSON formatted response
+	// Hackily extract the fields we are interested in
+	
+	size_t pos;
+	memUsage = netIn = netOut = userCpu = sysCpu = 0;
+
+		// Would really like a real JSON parser here...
+	pos = response.find("\"max_usage\"");
+	if (pos != std::string::npos) {
+		sscanf(response.c_str()+pos, "\"max_usage\":%ld", &memUsage);	
+	}
+	pos = response.find("\"tx_bytes\"");
+	if (pos != std::string::npos) {
+		sscanf(response.c_str()+pos, "\"tx_bytes\":%ld", &netOut);	
+	}
+	pos = response.find("\"rx_bytes\"");
+	if (pos != std::string::npos) {
+		sscanf(response.c_str()+pos, "\"rx_bytes\":%ld", &netIn);	
+	}
+	pos = response.find("\"usage_in_usermode\"");
+	if (pos != std::string::npos) {
+		sscanf(response.c_str()+pos, "\"usage_in_usermode\":%ld", &userCpu);	
+	}
+	pos = response.find("\"usage_in_kernelmode\"");
+	if (pos != std::string::npos) {
+		sscanf(response.c_str()+pos, "\"usage_in_kernelmode\":%ld", &sysCpu);	
+	}
+	dprintf(D_FULLDEBUG, "docker stats reports max_usage is %ld rx_bytes is %ld tx_bytes is %ld usage_in_usermode is %ld usage_in-sysmode is %ld\n", memUsage, netIn, netOut, userCpu, sysCpu);
+
+	return 0;
+#endif
+
+} /*
+ *  getting stats by running docker stats is now deprecated
+ */
+
+#if 0
 int
 DockerAPI::stats(const std::string &container, uint64_t &memUsage, uint64_t &netIn, uint64_t &netOut) {
+newstats(container, memUsage, netIn, netOut);
 	ArgList args;
 	if ( ! add_docker_arg(args))
 		return -1;
@@ -354,6 +461,8 @@ DockerAPI::stats(const std::string &container, uint64_t &memUsage, uint64_t &net
 	dprintf(D_FULLDEBUG, "memUsage is %g (%s), net In is %g (%s), net Out is %g (%s)\n", memRaw, memUsageUnit, netInRaw, netInUnit, netOutRaw, netOutUnit);
 	return 0;
 }
+#endif
+
 int DockerAPI::detect( CondorError & err ) {
 	// FIXME: Remove ::version() as a public API and return it from here,
 	// because there's no point in doing this twice.
diff --git a/src/condor_starter.V6.1/docker-api.h b/src/condor_starter.V6.1/docker-api.h
index f4bbb9a..1518a36 100644
--- a/src/condor_starter.V6.1/docker-api.h
+++ b/src/condor_starter.V6.1/docker-api.h
@@ -89,7 +89,7 @@ class DockerAPI {
 		// Only available in Docker 1.1 or later.
 		static int unpause( const std::string & container, CondorError & err );
 
-		static int stats(const std::string &container, uint64_t &memUsage, uint64_t &netIn, uint64_t &netOut);
+		static int stats(const std::string &container, uint64_t &memUsage, uint64_t &netIn, uint64_t &netOut, uint64_t &userCpu, uint64_t &sysCpu);
 
 		/**
 		 * Obtains the docker-inspect values State.Running and State.ExitCode.
diff --git a/src/condor_starter.V6.1/docker_proc.cpp b/src/condor_starter.V6.1/docker_proc.cpp
index 087539b..aeaa8ff 100644
--- a/src/condor_starter.V6.1/docker_proc.cpp
+++ b/src/condor_starter.V6.1/docker_proc.cpp
@@ -39,7 +39,7 @@ static void buildExtraVolumes(std::list<std::string> &extras);
 // the full container ID as (part of) the cgroup identifier(s).
 //
 
-DockerProc::DockerProc( ClassAd * jobAd ) : VanillaProc( jobAd ) { }
+DockerProc::DockerProc( ClassAd * jobAd ) : VanillaProc( jobAd ), updateTid(-1) { }
 
 DockerProc::~DockerProc() { }
 
@@ -144,7 +144,10 @@ int DockerProc::StartJob() {
 	dprintf( D_FULLDEBUG, "DockerAPI::run() returned pid %d\n", JobPid );
 
 
-	// TODO: Start a timer to poll for job usage updates.
+	// Start a timer to poll for job usage updates.
+	updateTid = daemonCore->Register_Timer(2, 
+			20, (TimerHandlercpp)&DockerProc::getStats, 
+				"DockerProc::getStats",this);
 
 	++num_pids; // Used by OsProc::PublishUpdateAd().
 	return TRUE;
@@ -155,6 +158,8 @@ bool DockerProc::JobReaper( int pid, int status ) {
 	TemporaryPrivSentry sentry(PRIV_ROOT);
 	dprintf( D_ALWAYS, "DockerProc::JobReaper()\n" );
 
+	daemonCore->Cancel_Timer(updateTid);
+
 	//
 	// This should mean that the container has terminated.
 	//
@@ -458,12 +463,15 @@ bool DockerProc::ShutdownFast() {
 }
 
 
+int
+DockerProc::getStats(int /*tid*/) {
+	DockerAPI::stats( containerName, memUsage, netIn, netOut, userCpu, sysCpu);
+	return true;
+}
+
 bool DockerProc::PublishUpdateAd( ClassAd * ad ) {
 	dprintf( D_ALWAYS, "DockerProc::PublishUpdateAd()\n" );
 
-	// TODO: get usage from procd somehow.  Set num_pids, if we can.  See
-	// VanillaProc::PublishUpdateAd() for the attributes to set.
-
 	//
 	// If we want to use the existing reporting code (probably a good
 	// idea), we'll need to make sure that m_proc_exited, is_checkpointed,
@@ -480,9 +488,6 @@ bool DockerProc::PublishUpdateAd( ClassAd * ad ) {
 	// or set them during our status polling.
 	//
 
-	uint64_t memUsage, netIn, netOut;
-	DockerAPI::stats( containerName, memUsage, netIn, netOut);
-
 	if (memUsage > 0) {
 		// Set RSS, Memory and ImageSize to same values, best we have
 		ad->Assign(ATTR_RESIDENT_SET_SIZE, int(memUsage / 1024));
@@ -490,6 +495,7 @@ bool DockerProc::PublishUpdateAd( ClassAd * ad ) {
 		ad->Assign(ATTR_IMAGE_SIZE, int(memUsage / (1024 * 1024)));
 		ad->Assign(ATTR_NETWORK_IN, double(netIn) / (1024 * 1024));
 		ad->Assign(ATTR_NETWORK_OUT, double(netOut) / (1024 * 1024));
+		ad->Assign(ATTR_JOB_REMOTE_USER_CPU, (int) (userCpu / (1024l * 1024l * 1024l)));
 	}
 	return OsProc::PublishUpdateAd( ad );
 }
diff --git a/src/condor_starter.V6.1/docker_proc.h b/src/condor_starter.V6.1/docker_proc.h
index 25011eb..a713607 100644
--- a/src/condor_starter.V6.1/docker_proc.h
+++ b/src/condor_starter.V6.1/docker_proc.h
@@ -30,6 +30,7 @@ class DockerProc : public VanillaProc {
 		virtual bool PublishUpdateAd( ClassAd * jobAd );
 		virtual void PublishToEnv( Env * env );
 
+		virtual int getStats(int tid);
 		static bool Detect();
 		static bool Version( std::string & version );
 
@@ -37,6 +38,8 @@ class DockerProc : public VanillaProc {
 
 		std::string containerID;
 		std::string containerName;
+		int updateTid;
+		uint64_t memUsage, netIn, netOut, userCpu, sysCpu;
 };
 
 #endif /* _CONDOR_DOCKER_PROC_H */
-- 
2.5.5

